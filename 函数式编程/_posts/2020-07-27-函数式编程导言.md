---
layout: post
title: 函数式编程导言
---

# 函数式编程导言
本文着重于从全局的高度提供函数式编程的概览, 作为函数式编程这个系列博客的引子, 所有提到的概念都会在这个系列的其他博客中进行补充说明.  

学习函数式编程有两条线索:
1. 以是否严格控制副作用作为区分
2. 以是否采用了代数数据类型作为区分.  
不严格限制副作用的风格(称为允许副作用式FP),常见库:[Ramda](https://ramdajs.com/).  
以Haskell为代表的静态类型函数式编程(称为严格控制副作用式FP), 常用TS库:[fp-ts](https://gcanti.github.io/fp-ts/)

## 允许副作用式FP

示例:
```typescript
import * as R from 'ramda';

type LogMaxNumber = (xs: number[]) => void;
const logMaxNumber: LogMaxNumber = R.pipe(
    R.reduce<number, number>(R.max, Number.MIN_VALUE),
    console.log
);

// log: 5
logMaxNumber([1, 2, 3, 4, 5]);
```

上述示例代码中, 通过应用`管道`和`柯里化`, 我们灵活地将"小函数"组合成我们要地"大函数".  
`管道`和`柯里化`相辅相成, 与`通用数据结构`组合使用, 赋予了这个范式极大的函数组合灵活性.

### 科里化和管道操作

### 通用数据结构提升函数的复用性

## 严格控制副作用式FP
示例:
```typescript
import * as fp from 'fp-ts';

type LogMaxNumber = (xs: number[]) => fp.io.IO<void>;
const logMaxNumber: LogMaxNumber = fp.function.flow(
    fp.nonEmptyArray.max(fp.ord.ordNumber),
    fp.console.log
);
ªª
const main: () => void = () => logMaxNumber([1, 2, 3, 4, 5])();

/*
log: 5
note: The entry point of the program is the only place where side effects are allowed
*/
main();
```

在这个`严格控制副作用式FP`的例子中, 我们将副作用(console.log)推迟到`main`函数进行,  
从而实现副作用的隔离 -- 整个程序除了`main`函数外, 其他代码都是无副作用的.    

详细阐述请阅读[此博客TODO](TODO)

## 代数数据类型
这是我们使用`static land`的定义:
> Algebra is a set of requirements for modules, like to match some signature and to obey some laws.
> A module is a JavaScript object with some static functions and/or values

换句话说, 代数数据类型是某些符合一系列要求的对象, 遵循了某些运算规律, 拥有某些类型的静态方法.  
以`Setoid`(或名Eq)代数数据类型为例子, 
```typescript
export interface Setoid<A> {
  readonly equals: (x: A, y: A) => boolean
}
```

从上述代码示例中可以发现, `Setoid`代数数据类型即为拥有`equal`方法的JS对象  
除此之外, `Setoid`还应遵循下列运算规律:
1. Reflexivity: S.equals(a, a) === true
2. Symmetry(对称性): S.equals(a, b) === S.equals(b, a)
3. Transitivity(传递性): 若 S.equals(a, b) 且 S.equals(b, c), 则 S.equals(a, c)

--- 

参考:
1. [static land定义](https://github.com/fantasyland/static-land/blob/master/docs/spec.md)