---
layout: post
title: 函数式编程导言
---

# 函数式编程导言
本文着重于从全局的高度提供函数式编程的概览, 作为函数式编程这个系列博客的引子, 所有提到的概念都会在这个系列的其他博客中进行补充说明.  
本文思维导图: TODO

函数式编程分两大分支: 

1. 关注函数组合性,不严格限制副作用的风格(称为允许副作用式FP),常见库:[Ramda](https://ramdajs.com/)
2. 以Haskell为代表的静态类型函数式编程(称为严格控制副作用式FP), 常用TS库:[fp-ts](https://gcanti.github.io/fp-ts/)

## 允许副作用式FP

示例:
```typescript
import * as R from 'ramda';

type LogMaxNumber = (xs: number[]) => void;
const logMaxNumber: LogMaxNumber = R.pipe(
    R.reduce<number, number>(R.max, Number.MIN_VALUE),
    console.log
);

// log: 5
logMaxNumber([1, 2, 3, 4, 5]);
```

上述示例代码中, 通过应用`管道`和`柯里化`, 我们灵活地将*小*函数组合成我们要地*大*函数.  
`管道`和`柯里化`相辅相成, 与`通用数据结构`组合使用, 赋予了这个范式极大的函数组合灵活性.
详细阐述请阅读[此博客TODO](TODO)

## 严格控制副作用式FP
例子
```typescript
import * as fp from 'fp-ts';

type LogMaxNumber = (xs: number[]) => fp.io.IO<void>;
const logMaxNumber: LogMaxNumber = fp.function.flow(
    fp.nonEmptyArray.max(fp.ord.ordNumber),
    fp.console.log
);
ªª
const main: () => void = () => logMaxNumber([1, 2, 3, 4, 5])();

/*
log: 5
note: The entry point of the program is the only place where side effects are allowed
*/
main();
```

在这个`严格控制副作用式FP`的例子中, 我们将副作用(console.log)推迟到`main`函数进行,  
从而实现副作用的隔离 -- 整个程序除了`main`函数外, 其他代码都是无副作用的.    

详细阐述请阅读[此博客TODO](TODO)