---
layout: post
title: TS重要不常用的知识
---

# TS重要不常用的知识
本文重点讨论TS中两种类型知识:
- 不常用, 但在类型系统中比较重要, 在其他编程语言广泛应用的知识.
- 不常用, 但在编写表达复杂的TS类型必须用到的知识.

## subtype与supertype
若要使类型`A`为类型` B`的subtype, 
那么必须使得所有传入类型`A `的值的地方都可以使用类型`B`的值进行替换,
即, [里氏替换原则](https://www.wikiwand.com/en/Liskov_substitution_principle).

## 类型的上界(upper type bound)和下界(lower type bound)
当我们称类型A的上界为类型B时, 即, 类型A满足约束: 类型A为类型B的*subtype*.
当我们称类型A的下界为类型B时, 即, 类型A满足约束: 类型A为类型B的*supertype*.
 

## 协变(covariance)与逆变(contravariance)
协变是在类型`T<A>`中, 当类型`B`为类型`A`的*subtype*时, 可得出`T<B>`为`T<A>`的subtype.

逆变是指类型`T<A>`中, 当类型`B`为类型`A`的*supertype*时, 可得出`T<B>`为`T<A>`的subtype.

举例来说, 在scala中, 针对函数类型`type T[A,B] = A => B`中, `A`具有逆变性, `B`具有协变性, 以下为推理过程.

*该过程是从类型需要满足的条件往回推, 类似极限的证明.*

使用函数`A => B`的地方传入的实参的上界为`A`, 即所有传入的实参为类型`A`的`subtype`,
若要使得函数`A1 => B1`为`A => B`的`subtype`, 需使得, `A1 => B1`的参数`A1`能够接受所有类型A的`subtype`,
即, `A1`需要为`A`的`supertype`.

同理, 使用函数`A => B`的地方对函数返回值的使用要求其拥有类型`B`的一切特性,
如要使得函数`A => B1`为`A => B`的`subtype`, 需使得, `A => B1`的返回值`B1`拥有类型`B`的一切特性,
即, `B1`需要为`B`的`subtype`.

推理完毕, 由推理过程可知, 函数在参数位置具有逆变性, 在返回值位置具有协变性.

### TS中的函数参数具有逆变性
在`--strictFunctionTypes`模式(`--strict`模式的子集)下, TS的函数的参数具有逆变性, 示例这里截取官方示例:
```typescript
declare let f1: (x: Animal) => void;
declare let f2: (x: Dog) => void;
declare let f3: (x: Cat) => void;
f1 = f2; // Error with --strictFunctionTypes
f2 = f1; // Ok
f2 = f3; // Error
```

## TS的`conditional types`具有分配性.
示例:
```typescript

```

--- 
参考:
- [condition type的MR](https://github.com/microsoft/TypeScript/pull/21316)
